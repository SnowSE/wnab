@page "/transactions"
@inject TransactionsViewModel ViewModel
@inject WNAB.MVM.IAuthenticationService AuthService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="page-container">
    <div class="accounts-header">
        <div class="header-text">
            <h1 class="page-title">Transactions</h1>
        </div>
        <div class="header-actions">
            <button class="btn btn-outline-secondary" @onclick="() => ViewModel.ToggleAddFormCommand.Execute(null)">
                <i class="bi bi-@(ViewModel.IsAddFormVisible ? "x-circle" : "plus-circle") me-1"></i>
                @(ViewModel.IsAddFormVisible ? "Cancel" : "New Transaction")
            </button>
            <button class="btn btn-outline-secondary ms-2" @onclick="OnRefreshClick" disabled="@ViewModel.Model.IsBusy">
                @if (ViewModel.Model.IsBusy)
                {
                    <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                }
                else
                {
                    <i class="bi bi-arrow-clockwise me-1"></i>
                }
                Refresh
            </button>
        </div>
    </div>

    @if (!ViewModel.Model.IsLoggedIn)
    {
        <div class="alert alert-warning">
            <i class="bi bi-exclamation-triangle me-1"></i>
            Please log in to view transactions.
        </div>
    }

<!-- Inline Add Transaction Form -->
@if (ViewModel.IsAddFormVisible && ViewModel.Model.IsLoggedIn)
{
	<div class="card mb-4 shadow-sm">
		<div class="card-header bg-primary text-white">
			<h5 class="mb-0"><i class="bi bi-plus-circle me-2"></i>Create New Transaction</h5>
		</div>
		<div class="card-body">
			@if (!string.IsNullOrWhiteSpace(ViewModel.AddTransactionViewModel.Model.StatusMessage))
			{
				<div class="alert @GetAlertClass(ViewModel.AddTransactionViewModel.Model.StatusMessage) mb-3">
					@ViewModel.AddTransactionViewModel.Model.StatusMessage
				</div>
			}

			<EditForm Model="ViewModel.AddTransactionViewModel.Model" OnValidSubmit="OnCreateTransactionSubmit">
				<div class="row g-3">
					<div class="col-md-3">
						<label class="form-label">Account</label>
						<select class="form-select" @bind="ViewModel.AddTransactionViewModel.Model.AccountId" required>
							<option value="0">Select account...</option>
							@foreach (var account in ViewModel.AddTransactionViewModel.Model.AvailableAccounts)
							{
								<option value="@account.Id">@account.AccountName</option>
							}
						</select>
					</div>
					<div class="col-md-3">
						<label class="form-label">Date</label>
						<input type="date" class="form-control" @bind="ViewModel.AddTransactionViewModel.Model.TransactionDate" required />
					</div>
					<div class="col-md-3">
						<label class="form-label">Payee</label>
						<input class="form-control" @bind="ViewModel.AddTransactionViewModel.Model.Payee" required />
					</div>
					<div class="col-md-3">
						<label class="form-label">Amount</label>
						<input type="number" step="0.01" class="form-control" @bind="ViewModel.AddTransactionViewModel.Model.Amount" required />
					</div>
				</div>

				<div class="row g-3 mt-2">
					<div class="col-md-9">
						<div class="d-flex align-items-center gap-2 mb-2">
							<label class="form-label mb-0">Category (Optional)</label>
							<button type="button" class="btn btn-sm btn-outline-primary" @onclick="ViewModel.AddTransactionViewModel.ToggleSplitTransactionCommand.Execute">
								@(ViewModel.AddTransactionViewModel.Model.IsSplitTransaction ? "Single Category" : "Split Transaction")
							</button>
						</div>

						@if (!ViewModel.AddTransactionViewModel.Model.IsSplitTransaction)
						{
							<select class="form-select" @bind="ViewModel.AddTransactionViewModel.Model.CategoryId">
								<option value="-1">Income</option>
								<option value="0">No Category</option>
								@foreach (var category in ViewModel.AddTransactionViewModel.Model.AvailableCategories)
								{
									<option value="@category.Id">@category.Name</option>
								}
							</select>
						}
						else
						{
							<div class="border rounded p-3 bg-light">
								@foreach (var split in ViewModel.AddTransactionViewModel.Model.Splits)
								{
									<div class="row g-2 mb-2 align-items-center">
										<div class="col-md-6">
											<select class="form-select form-select-sm"
													value="@(split.Model.SelectedCategory?.Id ?? 0)"
													@onchange="(e) => OnSplitCategoryChanged(split, e)">
												<option value="-1">Income</option>
												<option value="0">No Category</option>
												@foreach (var category in ViewModel.AddTransactionViewModel.Model.AvailableCategories)
												{
													<option value="@category.Id">@category.Name</option>
												}
											</select>
										</div>
										<div class="col-md-4">
											<input type="number" step="0.01" class="form-control form-control-sm"
												   @bind="split.Model.Amount" placeholder="0.00" />
										</div>
										<div class="col-md-2">
											<button type="button" class="btn btn-sm btn-danger w-100"
													@onclick="() => ViewModel.AddTransactionViewModel.RemoveSplitCommand.Execute(split)"
													disabled="@(ViewModel.AddTransactionViewModel.Model.Splits.Count <= 1)">
												ï¿½
											</button>
										</div>
									</div>
								}

								<button type="button" class="btn btn-sm btn-success mb-2" @onclick="ViewModel.AddTransactionViewModel.AddSplitCommand.Execute">
									+ Add Split
								</button>

								<div class="d-flex align-items-center gap-2 mt-2">
									<small class="text-muted">Balance:</small>
									<small class="fw-bold @(ViewModel.AddTransactionViewModel.Model.AreSplitsBalanced ? "text-success" : "text-danger")">
										@ViewModel.AddTransactionViewModel.Model.RemainingAmount.ToString("C")
									</small>
									<small class="text-muted">remaining</small>
								</div>
							</div>
						}
					</div>
					<div class="col-md-3">
						<label class="form-label">Memo (Optional)</label>
						<textarea class="form-control" rows="3" @bind="ViewModel.AddTransactionViewModel.Model.Memo"></textarea>
					</div>
				</div>

				<div class="d-flex justify-content-end gap-2 mt-3">
					<button type="button" class="btn btn-secondary" @onclick="() => ViewModel.CancelAddTransactionCommand.Execute(null)">Cancel</button>
					<button class="btn btn-primary" type="submit" disabled="@ViewModel.AddTransactionViewModel.Model.IsBusy">
						@if (ViewModel.AddTransactionViewModel.Model.IsBusy)
						{
							<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
						}
						Create Transaction
					</button>
				</div>
			</EditForm>
		</div>
	</div>
}

<!-- Transactions with Splits Section -->
<div class="responsive-panel mb-4">
	@if (ViewModel.Model.Items == null)
	{
		<div class="text-center p-4">
			<div class="spinner-border text-primary" role="status">
				<span class="visually-hidden">Loading...</span>
			</div>
			<p class="mt-2 text-muted">Loading transactions...</p>
		</div>
	}
	else if (ViewModel.Model.Items.Count == 0)
	{
		<div class="text-center p-4">
			<i class="bi bi-receipt fs-1 text-muted"></i>
			<p class="mt-2">No transactions found. Click "New Transaction" to add your first transaction.</p>
		</div>
	}
	else
	{
		<div class="table-responsive">
			<table class="table table-hover align-middle">
				<thead class="table-light">
					<tr>
						<th>Date</th>
						<th>Payee</th>
						<th>Account</th>
						<th class="text-end">Amount</th>
						<th width="140">Actions</th>
					</tr>
				</thead>
				<tbody>
					@foreach (var transaction in ViewModel.Model.Items)
					{
						var isEditing = _editingTransactionId == transaction.Id;
						
						@if (!isEditing)
						{
							<!-- Read-Only Transaction Row -->
							<tr class="table-primary" @key="@($"tx-{transaction.Id}")">
								<td>@transaction.Date.ToString("MM/dd/yyyy")</td>
								<td><strong>@transaction.Payee</strong></td>
								<td>@transaction.AccountName</td>
								<td class="text-end">
									<span class="@(transaction.Amount >= 0 ? "text-success" : "text-danger") fw-bold">
										@transaction.Amount.ToString("C")
									</span>
								</td>
								<td>
									<button class="btn btn-sm btn-outline-primary" @onclick="() => StartEditTransaction(transaction.Id)" title="Edit Transaction">
										<i class="bi bi-pencil"></i>
									</button>
									<button class="btn btn-sm btn-outline-danger ms-1" @onclick="() => DeleteTransaction(transaction.Id)" title="Delete Transaction">
										<i class="bi bi-trash"></i>
									</button>
								</td>
							</tr>

							<!-- Read-Only Split Rows -->
							@foreach (var split in transaction.Splits)
							{
								<tr class="table-light" @key="@($"split-{split.Id}")">
									<td class="ps-5">
										<i class="bi bi-arrow-return-right me-2 text-muted"></i>
										<small class="text-muted">Split #@split.Id</small>
									</td>
									<td colspan="2">
										@split.CategoryName
										@if (!string.IsNullOrWhiteSpace(split.Description))
										{
											<small class="text-muted ms-2">@split.Description</small>
										}
									</td>
									<td class="text-end">
										<span class="@(split.Amount >= 0 ? "text-success" : "text-danger")">
											@split.Amount.ToString("C")
										</span>
									</td>
									<td></td>
								</tr>
							}
						}
						else
						{
							<!-- Inline Edit Transaction Row -->
							<tr class="table-warning" style="border: 2px solid #ffc107;" @key="@($"tx-edit-{transaction.Id}")">
								<td colspan="5" class="p-0">
									<div class="p-3" style="background-color: #fff3cd;">
										<div class="row g-2 mb-2">
											<div class="col-md-3">
												<label class="form-label small">Date</label>
												<input type="date" class="form-control form-control-sm" @bind="_editDate" />
											</div>
											<div class="col-md-3">
												<label class="form-label small">Payee</label>
												<input class="form-control form-control-sm" @bind="_editPayee" />
											</div>
										<div class="col-md-3">
											<label class="form-label small">Account</label>
											<select class="form-select form-select-sm" @bind="_editAccountId">
												<option value="0">Select account...</option>
												@foreach (var account in _availableAccounts)
												{
													<option value="@account.Id">@account.AccountName</option>
												}
											</select>
										</div>
											<div class="col-md-3">
												<label class="form-label small">Amount</label>
												<input type="number" step="0.01" class="form-control form-control-sm" @bind="_editAmount" />
											</div>
										</div>
										<div class="row g-2 mb-3">
											<div class="col-md-12">
												<label class="form-label small">Memo</label>
												<input class="form-control form-control-sm" @bind="_editDescription" />
											</div>
										</div>

										<!-- Editable Splits Section -->
										<div class="mb-3">
											<h6 class="mb-2">Splits</h6>
											@for (int i = 0; i < _editingSplits.Count; i++)
											{
												var index = i;
												var split = _editingSplits[index];
												<div class="row g-2 mb-2 align-items-end" @key="@($"edit-split-{index}")">
													<div class="col-md-4">
														<label class="form-label small">Category</label>
														<select class="form-select form-select-sm" @bind="split.CategoryId">
															<option value="-1">Income</option>
															<option value="0">No Category</option>
															@foreach (var category in _availableCategories)
															{
																<option value="@category.Id">@category.Name</option>
															}
														</select>
													</div>
													<div class="col-md-3">
														<label class="form-label small">Amount</label>
														<input type="number" step="0.01" class="form-control form-control-sm" @bind="split.Amount" />
													</div>
													<div class="col-md-4">
														<label class="form-label small">Notes</label>
														<input class="form-control form-control-sm" @bind="split.Description" />
													</div>
													<div class="col-md-1">
														<button type="button" class="btn btn-sm btn-danger w-100" @onclick="() => RemoveEditingSplit(index)" title="Delete Split">
															<i class="bi bi-trash"></i>
														</button>
													</div>
												</div>
											}
											<button type="button" class="btn btn-sm btn-success mt-2" @onclick="AddEditingSplit">
												<i class="bi bi-plus-circle me-1"></i> Add Split
											</button>

											@if (!AreSplitsBalanced)
											{
												<div class="alert alert-danger mt-2 mb-0 py-2">
													<small><i class="bi bi-exclamation-triangle me-1"></i>Splits must sum to transaction amount. Current difference: @GetSplitDifference().ToString("C")</small>
												</div>
											}
										</div>

										<!-- Save/Cancel Buttons -->
										<div class="d-flex justify-content-end gap-2 mt-3">
											<button type="button" class="btn btn-sm btn-secondary" @onclick="CancelEditTransaction">
												Cancel
											</button>
											<button type="button" class="btn btn-sm btn-primary" @onclick="SaveEditTransaction" disabled="@(!AreSplitsBalanced)">
												Save Transaction
											</button>
										</div>
									</div>
								</td>
							</tr>
						}
					}
				</tbody>
			</table>
		</div>
	}
</div>
</div>

@code {
	// LLM-Dev: Thin presentation layer - all logic delegated to ViewModel

	// Local state for inline editing
	private class EditingSplit
	{
		public int Id { get; set; }
		public int? CategoryAllocationId { get; set; }
		public int? CategoryId { get; set; }  // Store the category ID, not allocation ID
		public string CategoryName { get; set; } = "";
		public decimal Amount { get; set; }
		public string? Description { get; set; }
	}

	private int? _editingTransactionId = null;
	private List<EditingSplit> _editingSplits = new();
	private DateTime _editDate;
	private string _editPayee = "";
	private int _editAccountId;
	private string _editAccount = "";
	private decimal _editAmount;
	private string _editDescription = "";
	private List<Account> _availableAccounts = new();
	private List<Category> _availableCategories = new();

	private bool AreSplitsBalanced => Math.Abs(GetSplitDifference()) < 0.01m;
	
	private decimal GetSplitDifference() => _editAmount - _editingSplits.Sum(s => s.Amount);

	protected override async Task OnInitializedAsync()
	{
		// Check if user is authenticated and token is valid
		if (AuthService is WNAB.Web.Services.WebAuthenticationService webAuthService)
		{
			var isAuthenticated = await AuthService.IsAuthenticatedAsync();
			var isTokenExpired = await webAuthService.IsTokenExpiredAsync();

			if (!isAuthenticated || isTokenExpired)
			{
				Navigation.NavigateTo("/landing");
				return;
			}
		}

		// Subscribe to property changes to trigger UI updates
		ViewModel.PropertyChanged += OnViewModelPropertyChanged;
		ViewModel.Model.PropertyChanged += OnModelPropertyChanged;
		ViewModel.AddTransactionViewModel.Model.PropertyChanged += OnAddTransactionModelPropertyChanged;

		await ViewModel.InitializeAsync();
	}

	private void OnViewModelPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
	{
		InvokeAsync(StateHasChanged);
	}

	private void OnModelPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
	{
		InvokeAsync(StateHasChanged);
	}

	private void OnAddTransactionModelPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
	{
		InvokeAsync(StateHasChanged);
	}

	private async Task OnRefreshClick()
	{
		await ViewModel.RefreshCommand.ExecuteAsync(null);
	}

	// Form submit handlers
	private async Task OnCreateTransactionSubmit()
	{
		await ViewModel.SaveTransactionInlineCommand.ExecuteAsync(null);
	}

	// Inline editing methods
	private void StartEditTransaction(int transactionId)
	{
		// Cancel any other editing
		if (_editingTransactionId.HasValue && _editingTransactionId.Value != transactionId)
		{
			CancelEditTransaction();
		}

		_editingTransactionId = transactionId;
		
		// Load transaction data into local edit fields
		var transaction = ViewModel.Model.Items.FirstOrDefault(t => t.Id == transactionId);
		if (transaction != null)
		{
			_editDate = transaction.Date;
			_editPayee = transaction.Payee;
			_editAccount = transaction.AccountName;
			_editAmount = transaction.Amount;
			_editDescription = transaction.Description ?? "";
			
			// Load available accounts and categories from AddTransactionViewModel
			_availableAccounts = ViewModel.AddTransactionViewModel.Model.AvailableAccounts.ToList();
			_availableCategories = ViewModel.AddTransactionViewModel.Model.AvailableCategories.ToList();
			
			// Find the account ID by name (since TransactionItem doesn't expose AccountId)
			var account = _availableAccounts.FirstOrDefault(a => a.AccountName == transaction.AccountName);
			_editAccountId = account?.Id ?? 0;
			
			// Load splits for this transaction
			_editingSplits = transaction.Splits.Select(s => {
				// Find the category by name to get its ID
				var category = _availableCategories.FirstOrDefault(c => c.Name == s.CategoryName);
				return new EditingSplit
				{
					Id = s.Id,
					CategoryAllocationId = s.CategoryAllocationId,
					CategoryId = category?.Id ?? (s.CategoryName == "Income" ? -1 : 0),
					CategoryName = s.CategoryName,
					Amount = s.Amount,
					Description = s.Description
				};
			}).ToList();
			
			// If no splits, add one empty split
			if (_editingSplits.Count == 0)
			{
				_editingSplits.Add(new EditingSplit 
				{ 
					Id = 0, 
					CategoryAllocationId = null,
					CategoryId = 0,
					CategoryName = "No Category",
					Amount = 0, 
					Description = "" 
				});
			}
		}
		
		StateHasChanged();
	}

	private void CancelEditTransaction()
	{
		_editingTransactionId = null;
		_editingSplits.Clear();
		StateHasChanged();
	}

	private async Task SaveEditTransaction()
	{
		if (!_editingTransactionId.HasValue) return;

		var transactionId = _editingTransactionId.Value;
		
		// Capture the current split IDs BEFORE making any changes
		var transaction = ViewModel.Model.Items.FirstOrDefault(t => t.Id == transactionId);
		var existingSplitIds = transaction?.Splits.Select(s => s.Id).ToHashSet() ?? new HashSet<int>();
		
		// Load the transaction for editing using ViewModel
		await ViewModel.ModifyTransactionCommand.ExecuteAsync(transactionId);
		
		// Update the EditTransactionViewModel with our local values
		ViewModel.EditTransactionViewModel.Model.TransactionDate = _editDate;
		ViewModel.EditTransactionViewModel.Model.Payee = _editPayee;
		ViewModel.EditTransactionViewModel.Model.AccountId = _editAccountId;
		ViewModel.EditTransactionViewModel.Model.Amount = _editAmount;
		ViewModel.EditTransactionViewModel.Model.Description = _editDescription;
		
		// Save the transaction first
		await ViewModel.SaveEditTransactionCommand.ExecuteAsync(null);

		// Now handle splits - determine which to update, create, or delete
		var editingSplitIds = _editingSplits.Where(s => s.Id > 0).Select(s => s.Id).ToHashSet();
		
		// Delete any splits that were removed (do this first to avoid conflicts)
		foreach (var existingId in existingSplitIds)
		{
			if (!editingSplitIds.Contains(existingId))
			{
				await ViewModel.DeleteTransactionSplitCommand.ExecuteAsync(existingId);
			}
		}

		// Update or create splits
		foreach (var editingSplit in _editingSplits)
		{
			if (editingSplit.Id > 0 && existingSplitIds.Contains(editingSplit.Id))
			{
				// Existing split - update it
				await JSRuntime.InvokeVoidAsync("console.log", $"Updating existing split {editingSplit.Id} with category ID {editingSplit.CategoryId}");
				
				// Load the split into the edit view model
				await ViewModel.ModifyTransactionSplitCommand.ExecuteAsync(editingSplit.Id);
				
				// Update the split based on category selection
				if (editingSplit.CategoryId.HasValue && editingSplit.CategoryId.Value > 0)
				{
					// Regular category - find it and let the allocation lookup happen
					var category = _availableCategories.FirstOrDefault(c => c.Id == editingSplit.CategoryId.Value);
					if (category != null)
					{
						ViewModel.EditTransactionSplitViewModel.Model.SelectedCategory = category;
						
						// Give the async allocation lookup a moment to complete
						// await Task.Delay(100);
						
						ViewModel.EditTransactionSplitViewModel.Model.Amount = editingSplit.Amount;
						ViewModel.EditTransactionSplitViewModel.Model.Description = editingSplit.Description;
						
						await ViewModel.SaveEditTransactionSplitCommand.ExecuteAsync(null);
					}
				}
				else if (editingSplit.CategoryId == -1)
				{
					// Income - set CategoryAllocationId to null
					ViewModel.EditTransactionSplitViewModel.Model.CategoryAllocationId = null;
					ViewModel.EditTransactionSplitViewModel.Model.Amount = editingSplit.Amount;
					ViewModel.EditTransactionSplitViewModel.Model.Description = editingSplit.Description;
					await ViewModel.SaveEditTransactionSplitCommand.ExecuteAsync(null);
				}
				else
				{
					// No category (CategoryId == 0 or null) - set allocation to null
					ViewModel.EditTransactionSplitViewModel.Model.CategoryAllocationId = null;
					ViewModel.EditTransactionSplitViewModel.Model.Amount = editingSplit.Amount;
					ViewModel.EditTransactionSplitViewModel.Model.Description = editingSplit.Description;
					await ViewModel.SaveEditTransactionSplitCommand.ExecuteAsync(null);
				}
			}
			else if (editingSplit.Id == 0)
			{
				// New split - create it
				// Skip if no category is selected
				if (!editingSplit.CategoryId.HasValue || editingSplit.CategoryId.Value == 0)
				{
					await JSRuntime.InvokeVoidAsync("console.warn", "Skipping split with no category");
					continue;
				}
				
				// First, load the transaction context (this sets the transaction date)
				await ViewModel.AddSplitToTransactionCommand.ExecuteAsync(transactionId);
				
				// Set the category by finding it in the available categories using CategoryId
				var category = _availableCategories.FirstOrDefault(c => c.Id == editingSplit.CategoryId.Value);
				if (category != null)
				{
					await JSRuntime.InvokeVoidAsync("console.log", $"Creating split with category {category.Name}, amount {editingSplit.Amount}");
					
					ViewModel.AddSplitToTransactionViewModel.Model.SelectedCategory = category;
					ViewModel.AddSplitToTransactionViewModel.Model.Amount = editingSplit.Amount;
					ViewModel.AddSplitToTransactionViewModel.Model.Notes = editingSplit.Description;
					
					await ViewModel.SaveAddSplitToTransactionCommand.ExecuteAsync(null);
					await JSRuntime.InvokeVoidAsync("console.log", "Split creation command executed");
				}
				else
				{
					await JSRuntime.InvokeVoidAsync("console.error", $"Category not found for ID {editingSplit.CategoryId}");
				}
			}
		}

		await JSRuntime.InvokeVoidAsync("console.log", "Refreshing transaction list...");
		
		// Refresh and close edit mode
		await ViewModel.RefreshCommand.ExecuteAsync(null);
		
		await JSRuntime.InvokeVoidAsync("console.log", "Refresh complete");
		CancelEditTransaction();
	}

	private void AddEditingSplit()
	{
		_editingSplits.Add(new EditingSplit 
		{ 
			Id = 0, 
			CategoryAllocationId = null,
			CategoryId = 0,
			CategoryName = "No Category",
			Amount = 0, 
			Description = "" 
		});
		StateHasChanged();
	}

	private async Task RemoveEditingSplit(int index)
	{
		if (_editingSplits.Count <= 1)
		{
			await JSRuntime.InvokeVoidAsync("alert", "A transaction must have at least one split.");
			return;
		}

		if (await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this split?"))
		{
			_editingSplits.RemoveAt(index);
			StateHasChanged();
		}
	}

	// Helper methods for split category selection
	private int GetSelectedCategoryId(AddTransactionSplitViewModel split)
	{
		return split.Model.SelectedCategory?.Id ?? 0;
	}

	private void OnSplitCategoryChanged(AddTransactionSplitViewModel split, ChangeEventArgs e)
	{
		if (e.Value != null && int.TryParse(e.Value.ToString(), out int categoryId))
		{
			if (categoryId == -1)
			{
				// Create a virtual "Income" category
				split.Model.SelectedCategory = new Category { Id = -1, Name = "Income", UserId = 0 };
			}
			else if (categoryId == 0)
			{
				split.Model.SelectedCategory = null;
			}
			else
			{
				var category = ViewModel.AddTransactionViewModel.Model.AvailableCategories.FirstOrDefault(c => c.Id == categoryId);
				split.Model.SelectedCategory = category;
			}
		}
	}

	// Helper method for add split to transaction form
	private void OnAddSplitCategoryChanged(ChangeEventArgs e)
	{
		if (e.Value != null && int.TryParse(e.Value.ToString(), out int categoryId))
		{
			var category = ViewModel.AddSplitToTransactionViewModel.Model.AvailableCategories.FirstOrDefault(c => c.Id == categoryId);
			ViewModel.AddSplitToTransactionViewModel.Model.SelectedCategory = category;
		}
	}

	// Action handlers for transactions
	private async Task ModifyTransaction(int transactionId)
	{
		await ViewModel.ModifyTransactionCommand.ExecuteAsync(transactionId);
	}

	private async Task DeleteTransaction(int transactionId)
	{
		if (await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this transaction?"))
		{
			await ViewModel.DeleteTransactionCommand.ExecuteAsync(transactionId);
		}
	}

	// Action handlers for splits
	private async Task ModifySplit(int splitId)
	{
		await ViewModel.ModifyTransactionSplitCommand.ExecuteAsync(splitId);
	}

	private async Task DeleteSplit(int splitId)
	{
		if (await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this split?"))
		{
			await ViewModel.DeleteTransactionSplitCommand.ExecuteAsync(splitId);
		}
	}

	private async Task AddSplitToTransaction(int transactionId)
	{
		await ViewModel.AddSplitToTransactionCommand.ExecuteAsync(transactionId);
	}

	private string GetAlertClass(string message)
	{
		if (message.Contains("Error") || message.Contains("Please") || message.Contains("Missing") || message.Contains("No "))
			return "alert-danger";
		if (message.Contains("success"))
			return "alert-success";
		return "alert-info";
	}

	public void Dispose()
	{
		if (ViewModel != null)
		{
			ViewModel.PropertyChanged -= OnViewModelPropertyChanged;
		}
		if (ViewModel?.Model != null)
		{
			ViewModel.Model.PropertyChanged -= OnModelPropertyChanged;
		}
		if (ViewModel?.AddTransactionViewModel?.Model != null)
		{
			ViewModel.AddTransactionViewModel.Model.PropertyChanged -= OnAddTransactionModelPropertyChanged;
		}
	}
}